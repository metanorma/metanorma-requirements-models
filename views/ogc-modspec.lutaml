diagram OGCModSpec {
  title "OGC 08-131r3 ModSpec"

  class Specification {
    definition {
      A specification, to become a standard must be approved by an authority,
      such as ISO or OGC. This gives the specification a namespace corresponding
      to the standards authority. Thus the name of the specification is usually
      a local name in this namespace.

      For example, "ISO 19107: Geographic Information – Spatial schema" is an
      approved specification of ISO TC 211 (the authority as a TC under ISO).
      The parts of the name that give this are "ISO" and "Geographic
      Information". The local name within this namespace is "19107: Spatial
      schema". This syntax is not usual for namespaces where the namespace name
      is usually either a prefix or suffix of the local name. GenericName,
      LocalName, Namespace are all types described in "ISO 19103: Geographic
      information – Conceptual schema language". The attributes of a
      Specification describe its local name, its authority, the date of
      publication and its current status (such as CD, DIS, IS in ISO, or Draft,
      Candidate Standard or Standard in OGC).
    }
    name: String {
      definition {
        Name of the specification.
      }
    }
    authority: Principal {
      definition {
        Standards body or author of this specification.
      }
    }
    date: DateTime {
      definition {
        Publication date of the specification.
      }
    }
    status: String {
      definition {
        Publication status of this specification.
      }
    }
  }

  class ConformanceSuite {
    definition {
      The unique conformance suite of a specification lists the tests (grouped
      into conformance test classes consisting of some number of conformance
      test modules, containing some number of conformance tests) that allow
      testing of an implementation of the specification for conformance with the
      specification. Every specification needs one of these suites, or
      conformance cannot be claimed with proof. In ISO and OGC, the conformance
      suite included in the specification is usually an abstract description of
      the tests which will be implemented. Other standards may use a more
      concrete description. For the purposes of this OGC standard, the precise
      nature of the conformance suite is not particularly important as long as
      it is not ambiguously stated.

      Each conformance test within a conformance class should be against a
      single standardization target defined for that class. A conformance suite
      may contain several defined conformance classes for the same
      standardization target.
    }
    classes: ConformanceClass[1..*] {
      definition {
        Conformance classes that this conformance suite contains.
      }
    }
  }

  class ConformanceClass {
    definition {
      The requirements in the requirements classes of a specification have to be
      tested and the conformance classes are the containers for these tests’
      definition. The requirements classes will have interdependencies, and this
      is reflected in the explicit dependencies between the conformance classes.
      If class "a" is dependent on class "b", then to pass the test for "a" a
      standardization target must also pass the test for "b." The class name is
      shared with its corresponding requirements class.
    }
    name: String {
      definition {
        Name of the conformance class.
      }
    }
    dependencies: ConformanceClass[0..*] {
      definition {
        Conformance classes that this conformance class depends on.
        These dependent conformance classes must be passed if this one is to be
        passed.
      }
    }
    requirementsClass: RequirementsClass {
      definition {
        The requirements class that this conformance class aims to test against.
      }
    }
  }

  class RequirementsClass {
    definition {
      The specification requirements classes (usually realized as clauses in the
      specification document) segment the requirements in the specification in a
      manner consistent with the conformance classes. Since the requirements
      class and the conformance class will eventually be referred to in a
      certification of conformance, they should have names, probably in the
      namespace defined by the specification’s name and authority.
    }
    name: String {
      definition {
        Name of the requirements class.
      }
    }
    dependencies: RequirementsClass[0..*] {
      definition {
        Requirements classes that this requirements class depends on.
        These dependent requirements classes must be satisfied for this
        requirements class to be satisfied.
      }
    }
    modules: RequirementsModule[1..*] {
      definition {
        Requirements modules that make up this requirements class.
      }
    }
    targetType: StandardizationTargetType {
      definition {
        Type of standardization target.
      }
    }
  }

  class RequirementsModule {
    definition {
      The specification requirements modules (usually realized as subclauses of
      the requirements class in the specification document) segment the
      requirements in the specification in a manner consistent with the
      conformance test modules.
    }

    name: String {
      definition {
        Name of the requirements module.
      }
    }

    requirements: Requirement[1..*] {
      definition {
        Requirements that this requirements module contains.
      }
    }
  }

  class NormativeStatement {
    definition {
      The normative statements, either requirements or recommendations of a
      standard, are organized into the requirements modules and classes, and may
      be tested by the conformance tests in their requirements class’s
      corresponding conformance class. If tested, the statement is a
      "Requirement", and if not tested the statement is a "Recommendation".
    }
    name: String {
      definition {
        Name of the normative statement.
      }
    }
  }

  class Requirement {
    definition {
      Normative statement that constitutes a requirement.
    }

    tests: ConformanceTest[1..*] {
      definition {
        Conformance tests that when passed confirm the satisfaction of this
        requirement.

        NOTE: If this requirement is a requirement part, it may or may not have
        a corresponding conformance test.
      }
    }

    parts: Requirement[0..*] {
      definition {
        Collection of requirements that are parts to this requirement.
        Satisfaction of all requirement parts are necessary for this requirement
        to be satisfied. Optional.
      }
    }
  }

  class Recommendation {
    definition {
      A normative suggestion which will not be directly tested is a
      "Recommendation." Recommendations have a variety of uses, for example:

      * Legal restriction, such as "not for commercial use" or "for planning
      purposes." These allow the specification to restrict use of its
      implementation to standardization targets for which it was designed.

      * Statement of best practices. These are included as suggestions for
      logical designs that may implement the requirements in the same module.

      Regardless of their use, Recommendations are not tested since they are not
      required of all conformant implementations.
    }
  }

  enum TestType {
    definition {
      Type of test.
    }
    basic {
      definition {
        Basic test.
      }
    }
    capabilities {
      definition {
        Test against capabilities.
      }
    }
  }

  class ConformanceTestMethod {
    requirements: Requirement[0..*] {
      definition {
        Corresponding requirement or requirement part that this conformance
        test method is supposed to test against. This is optional.
      }
    }
    steps: ConformanceTestStep[1..*] {
      definition {
        Test steps to be performed as part of this conformance test method.
        At least one test step is required.
      }
    }
  }

  class ConformanceTest {
    definition {
      A conformance test aims to satisfy a requirement and can potentially
      contain multiple test methods.
    }
    abstract: Boolean {
      definition {
        Whether this test is abstract or concrete. An abstract conformance test
        is commonly called an abstract test.
      }
    }
    testPurpose: String {
      definition {
        Purpose of the conformance test.
      }
    }
    testType: TestType {
      definition {
        Type of the conformance test.
      }
    }
    testMethod: ConformanceTestMethod[0..*] {
      definition {
        Method to perform this conformance test.
        A method is considered a "part" of the test if there are multiple of them.
      }
    }
    references: RichText[0..*] {
      definition {
        References to the specification(s) of the conformance test.
      }
    }
    requirements: Requirement[1..*] {
      definition {
        Corresponding requirement or requirement part that this conformance
        test is supposed to test against.
      }
    }
  }

  class ConformanceTestStep {
    definition {
      Test step to be performed within a conformance test.
    }
    content: RichText[1..*] {
      definition {
        Specification for executing the test step.
      }
    }
    inner: ConformanceTestStep[0..*] {
      definition {
        Inner test steps after performing the current test step.
      }
    }
  }

  class StandardizationTarget <<implementation>> {
    definition {
      Each conformance class (and hence requirements class) is targeted to a
      particular type of implementation. An implementation testable by a
      conformance class is a StandardizationTarget of that class, and (once the
      appropriate test have been passed) can carry a certificate indicating its
      conformance to a requirements class proved by the tests in the conformance
      class.
    }
    conformanceCertificates: String[0..*] {
      definition {
        conformance classes passed by this target
      }
    }
    type: StandardizationTargetType {
      definition {
        Type of the standardization target type.
      }
    }
  }

  class StandardizationTargetType <<metaclass>> {}

  class Principal {
    name: String
    contactInformation: String[1..*]
  }

  association {
    owner_type aggregation
    member_type direct
    owner StandardizationTargetType#targetType 1
    member RequirementsClass# [0..*]
  }

  //association {
  // owner ConformanceClass#requirements 1
  //  member RequirementsClass# 1
  //}

  //  association {
  //    owner_type composition
  //    member_type direct
  //    owner ConformanceSuite#testSuite
  //    member Specification
  //  }

  //  association {
  //    owner_type composition
  //    member_type direct
  //    owner RequirementsClass#class [1..*]
  //    member Specification
  //  }

  //  association {
  //    owner_type composition
  //    member_type direct
  //    owner ConformanceClass#class [1..*]
  //    member ConformanceSuite
  //  }

  //  association {
  //    owner_type composition
  //    member_type direct
  //    owner ConformanceModule#testSuite [1..*]
  //    member ConformanceClass
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner RequirementsClass
  //    member RequirementsModule#modules
  //  }

  //  association {
  //    owner StandardizationTarget
  //    member StandardizationTargetType
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner ConformanceModule
  //    member ConformanceTest#tests [1..*]
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner ConformanceTest
  //    member ConformanceTestMethod#methods [1..*]
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner ConformanceTestMethod
  //    member Requirement#requirements [1..*]
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner ConformanceTestMethod
  //    member ConformanceTestStep#steps [1..*]
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner RequirementsModule
  //    member Requirement#requirements [1..*]
  //  }

  //  association {
  //    owner_type direct
  //    member_type composition
  //    owner RequirementsClass
  //    member Requirement#requirements [1..*]
  //  }

  association {
    owner Requirement
    member NormativeStatement
  }

  association {
    owner Recommendation
    member NormativeStatement
  }

  association {
    owner_type direct
    member_type direct
    owner ConformanceTest#tests [1..*]
    member Requirement#requirements [1..*]
  }
}
